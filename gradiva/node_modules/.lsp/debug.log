Hello - from c:\Users\someo\.vscode\extensions\jaredly.reason-vscode-1.7.13\bin.native.exe.hot.exe
Previous log location: C:\Users\someo\AppData\Local\Temp\lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Users/someo/OneDrive/Documents/FMF/prog1/gradiva/programiranje-1/07-definicije-tipov/vaje/podatkovni_tipi.ml","languageId":"ocaml","version":1,"text":"(* ========== Vaja 3: Definicije Tipov  ========== *)\r\n\r\n(*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*]\r\n Pri modeliranju denarja ponavadi uporabljamo racionalna števila. Problemi se\r\n pojavijo, ko uvedemo različne valute.\r\n Oglejmo si dva pristopa k izboljšavi varnosti pri uporabi valut.\r\n[*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*)\r\n\r\n(*----------------------------------------------------------------------------*]\r\n Definirajte tipa [euro] in [dollar], kjer ima vsak od tipov zgolj en\r\n konstruktor, ki sprejme racionalno število.\r\n Nato napišite funkciji [euro_to_dollar] in [dollar_to_euro], ki primerno\r\n pretvarjata valuti (točne vrednosti pridobite na internetu ali pa si jih\r\n izmislite).\r\n\r\n Namig: Občudujte informativnost tipov funkcij.\r\n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\r\n # dollar_to_euro;;\r\n - : dollar -> euro = <fun>\r\n # dollar_to_euro (Dollar 0.5);;\r\n - : euro = Euro 0.4305\r\n[*----------------------------------------------------------------------------*)\r\n\r\n\r\n\r\n(*----------------------------------------------------------------------------*]\r\n Definirajte tip [currency] kot en vsotni tip z konstruktorji za jen, funt\r\n in švedsko krono. Nato napišite funkcijo [to_pound], ki primerno pretvori\r\n valuto tipa [currency] v funte.\r\n\r\n Namig: V tip dodajte še švicarske franke in se navdušite nad dejstvom, da vas\r\n        Ocaml sam opozori, da je potrebno popraviti funkcijo [to_pound].\r\n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\r\n # to_pound (Yen 100.);;\r\n - : currency = Pound 0.007\r\n[*----------------------------------------------------------------------------*)\r\n\r\n\r\n\r\n(*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*]\r\n Želimo uporabljati sezname, ki hranijo tako cela števila kot tudi logične\r\n vrednosti. To bi lahko rešili tako da uvedemo nov tip, ki predstavlja celo\r\n število ali logično vrednost, v nadaljevanju pa bomo raje konstruirali nov tip\r\n seznamov.\r\n\r\n Spomnimo se, da lahko tip [list] predstavimo s konstruktorjem za prazen seznam\r\n [Nil] (oz. [] v Ocamlu) in pa konstruktorjem za člen [Cons(x, xs)] (oz.\r\n x :: xs v Ocamlu).\r\n[*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*)\r\n\r\n(*----------------------------------------------------------------------------*]\r\n Definirajte tip [intbool_list] z konstruktorji za:\r\n  1.) prazen seznam,\r\n  2.) člen z celoštevilsko vrednostjo,\r\n  3.) člen z logično vrednostjo.\r\n\r\n Nato napišite testni primer, ki bi predstavljal \"[5; true; false; 7]\".\r\n[*----------------------------------------------------------------------------*)\r\n\r\n\r\n\r\n(*----------------------------------------------------------------------------*]\r\n Funkcija [intbool_map f_int f_bool ib_list] preslika vrednosti [ib_list] v nov\r\n [intbool_list] seznam, kjer na elementih uporabi primerno od funkcij [f_int]\r\n oz. [f_bool].\r\n[*----------------------------------------------------------------------------*)\r\n\r\nlet rec intbool_map = ()\r\n\r\n(*----------------------------------------------------------------------------*]\r\n Funkcija [intbool_reverse] obrne vrstni red elementov [intbool_list] seznama.\r\n Funkcija je repno rekurzivna.\r\n[*----------------------------------------------------------------------------*)\r\n\r\nlet rec intbool_reverse = ()\r\n\r\n(*----------------------------------------------------------------------------*]\r\n Funkcija [intbool_separate ib_list] loči vrednosti [ib_list] v par [list]\r\n seznamov, kjer prvi vsebuje vse celoštevilske vrednosti, drugi pa vse logične\r\n vrednosti. Funkcija je repno rekurzivna in ohranja vrstni red elementov.\r\n[*----------------------------------------------------------------------------*)\r\n\r\nlet rec intbool_separate = ()\r\n\r\n(*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*]\r\n Določeni ste bili za vzdrževalca baze podatkov za svetovno priznano čarodejsko\r\n akademijo \"Effemef\". Vaša naloga je konstruirati sistem, ki bo omogočil\r\n pregledno hranjenje podatkov.\r\n[*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*)\r\n\r\n(*----------------------------------------------------------------------------*]\r\n Čarodeje razvrščamo glede na vrsto magije, ki se ji posvečajo. Definirajte tip\r\n [magic], ki loči med magijo ognja, magijo ledu in magijo arkane oz. fire,\r\n frost in arcane.\r\n\r\n Ko se čarodej zaposli na akademiji, se usmeri v zgodovino, poučevanje ali\r\n raziskovanje oz. historian, teacher in researcher. Definirajte tip\r\n [specialisation], ki loči med temi zaposlitvami.\r\n[*----------------------------------------------------------------------------*)\r\n\r\n\r\n\r\n(*----------------------------------------------------------------------------*]\r\n Vsak od čarodejev začne kot začetnik, nato na neki točki postane študent,\r\n na koncu pa SE lahko tudi zaposli.\r\n Definirajte tip [status], ki določa ali je čarodej:\r\n  a.) začetnik [Newbie],\r\n  b.) študent [Student] (in kateri vrsti magije pripada in koliko časa študira),\r\n  c.) zaposlen [Employed] (in vrsto magije in specializacijo).\r\n\r\n Nato definirajte zapisni tip [wizard] z poljem za ime in poljem za trenuten\r\n status.\r\n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\r\n # professor;;\r\n - : wizard = {name = \"Matija\"; status = Employed (Fire, Teacher)}\r\n[*----------------------------------------------------------------------------*)\r\n\r\n\r\n\r\n(*----------------------------------------------------------------------------*]\r\n Želimo prešteti koliko uporabnikov posamezne od vrst magije imamo na akademiji.\r\n Definirajte zapisni tip [magic_counter], ki v posameznem polju hrani število\r\n uporabnikov magije.\r\n Nato definirajte funkcijo [update counter magic], ki vrne nov števec s\r\n posodobljenim poljem glede na vrednost [magic].\r\n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\r\n # update {fire = 1; frost = 1; arcane = 1} Arcane;;\r\n - : magic_counter = {fire = 1; frost = 1; arcane = 2}\r\n[*----------------------------------------------------------------------------*)\r\n\r\n\r\n\r\n(*----------------------------------------------------------------------------*]\r\n Funkcija [count_magic] sprejme seznam čarodejev in vrne števec uporabnikov\r\n različnih vrst magij.\r\n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\r\n # count_magic [professor; professor; professor];;\r\n - : magic_counter = {fire = 3; frost = 0; arcane = 0}\r\n[*----------------------------------------------------------------------------*)\r\n\r\nlet rec count_magic = ()\r\n\r\n(*----------------------------------------------------------------------------*]\r\n Želimo poiskati primernega kandidata za delovni razpis. Študent lahko postane\r\n zgodovinar po vsaj treh letih študija, raziskovalec po vsaj štirih letih\r\n študija in učitelj po vsaj petih letih študija.\r\n Funkcija [find_candidate magic specialisation wizard_list] poišče prvega\r\n primernega kandidata na seznamu čarodejev in vrne njegovo ime, čim ustreza\r\n zahtevam za [specialisation] in študira vrsto [magic]. V primeru, da ni\r\n primernega kandidata, funkcija vrne [None].\r\n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\r\n # let jaina = {name = \"Jaina\"; status = Student (Frost, 4)};;\r\n # find_candidate Frost Researcher [professor; jaina];;\r\n - : string option = Some \"Jaina\"\r\n[*----------------------------------------------------------------------------*)\r\n\r\nlet rec find_candidate = ()\r\n"}}}
